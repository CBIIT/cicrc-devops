pipeline {
	agent {
		node {
			label 'slave-ncias-d2999-c'
		}
	}

	parameters {

        string(
            defaultValue: '',
            description: 'The file name of the MySQL backup file',
            name: 'Backup_File')

        string(
            defaultValue: '',
            description: 'The S3 bucket to store the backup file',
            name: 'S3_Bucket')

        extendedChoice(
            name: 'Backup_Tier',
            defaultValue: 'dev',
            description: 'Choose the environment to back up',
            type: 'PT_SINGLE_SELECT',
            value: 'dev,qa')

        extendedChoice(
            name: 'Restore_Tier',
            defaultValue: 'dev',
            description: 'Choose the environment to restore to',
            type: 'PT_SINGLE_SELECT',
            value: 'dev,qa')

        booleanParam(
            defaultValue: true,
			description: 'Perform DB backup task',
            name: 'Backup_Database')

        booleanParam(
            defaultValue: true,
			description: 'Perform DB restore task',
            name: 'Restore_Database')

  }

  options {

	timestamps()

  }

  stages{

    stage('set variables'){

		environment {

	        BACKUP_TIER  = "${params.Backup_Tier}"
            RESTORE_TIER  = "${params.Restore_Tier}"

        }

        steps {

  		    script {

			    env.BAK_DB_HOST = sh(label: 'Get DB Host', returnStdout: true, script: "aws secretsmanager get-secret-value --secret-id cicrc/db/$BACKUP_TIER --query SecretString --output text | jq -r '.DB_HOST'")
                env.BAK_DB_NAME = sh(label: 'Get DB Name', returnStdout: true, script: "aws secretsmanager get-secret-value --secret-id cicrc/db/$BACKUP_TIER --query SecretString --output text | jq -r '.DB_NAME'")
                env.BAK_DB_USER = sh(label: 'Get DB User', returnStdout: true, script: "aws secretsmanager get-secret-value --secret-id cicrc/db/$BACKUP_TIER --query SecretString --output text | jq -r '.DB_USER'")
                env.BAK_DB_PASS = sh(label: 'Get DB Passsword', returnStdout: true, script: "aws secretsmanager get-secret-value --secret-id cicrc/db/$BACKUP_TIER --query SecretString --output text | jq -r '.DB_PASS'")
				

			}

        }

  	}

  	stage('backup db'){

	    when {
            expression {
                return params.Backup_Database;
            }
        }

		agent {
            docker {
                image 'mysql:8.0'
                //args '--net=host -u root -v /var/run/docker.sock:/var/run/docker.sock'
                reuseNode true
            }
        }

 		environment {

	        BACKUP_FILE  = "${params.Backup_File}"
	        BACKUP_TIER  = "${params.Backup_Tier}"

        }

		steps {

 			script {

                //BACKUP = sh(label: 'Get DB Backup', returnStdout: true, script: "mysqldump --no-tablespaces --single-transaction --add-drop-database --set-gtid-purged=OFF -h $BAK_DB_HOST $BAK_DB_NAME > $WORKSPACE/$BACKUP_FILE -u $BAK_DB_USER -p$BAK_DB_PASS")
                sh label: 'Backup-DB', script: """#!/bin/bash

				echo "Backing up DB:    $BACKUP_FILE - user:   $BAK_DB_USER"

                mkdir $WORKSPACE/mysqldump
                echo "[client]" > $WORKSPACE/sql.conf
                echo "host=$BAK_DB_HOST" >> $WORKSPACE/sql.conf
                echo "user=$BAK_DB_USER" >> $WORKSPACE/sql.conf
                echo "password=$BAK_DB_PASS" >> $WORKSPACE/sql.conf

                mysqldump --defaults-file=$WORKSPACE/sql.conf --no-tablespaces --single-transaction --add-drop-database --set-gtid-purged=OFF --result-file $WORKSPACE/mysqldump/$BACKUP_FILE $BAK_DB_NAME

				"""

			}

 		}

  	}

	stage('push backup to S3'){

	    when {
            expression {
                return params.Backup_Database;
            }
        }

 		environment {

	        BACKUP_FILE  = "${params.Backup_File}"
	        S3_BUCKET    = "${params.S3_Bucket}"

        }

		steps {

  		    script {

			    sh label: 'Push-To-S3', script: """#!/bin/bash

                aws s3 cp $WORKSPACE/mysqldump/$BACKUP_FILE s3://$S3_BUCKET

                echo "Backup File:  $BACKUP_FILE   Has been uploaded to:  $S3_BUCKET"

				"""

			}

        }

  	}

	stage('pull backup from S3'){

	    when {
            allof {
                expression { return params.Restore_Database; }
                expression { "$WORKSPACE/mysqldump/$params.Backup_File" == 'false' }
            }
        }

 		environment {

	        BACKUP_FILE  = "${params.Backup_File}"
	        S3_BUCKET    = "${params.S3_Bucket}"

        }

		steps {

  		    script {

			    sh label: 'Pull-From-S3', script: '''#!/bin/bash

				which aws

				pwd

				echo $WORKSPACE

				'''

			}

        }

  	}

  	stage('restore db'){

	    when {
            expression {
                return params.Restore_Database;
            }
        }

		agent {
            docker {
                image 'mysql:8.0'
                //args '--net=host -u root -v /var/run/docker.sock:/var/run/docker.sock'
                reuseNode true
            }
        }
		
 		environment {

	        BACKUP_FILE  = "${params.Backup_File}"
	        RESTORE_TIER = "${params.Restore_Tier}"

        }

 		steps {

 			script {

			    sh label: 'Restore-DB', script: '''#!/bin/bash

				echo "test:    $ECR_REPO"

				'''

			}

 		}

  	}

  }

  post {

    cleanup {

        cleanWs()

    }

  }

}